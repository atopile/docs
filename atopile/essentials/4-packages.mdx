---
title: '4. Packages'
#description: "One of the key benefits of designing circuit boards with code is that it unlocks modularity. As in software, this modularity means you can package up and reuse modules others have developed and tested."
icon: 'cubes'
---

One of the key benefits of designing circuit boards with code is that it unlocks modularity. As in software, this modularity means you can package up and reuse modules others have developed and tested.

## Finding packages

Check [first-party packages](https://packages.atopile.io/) for a list designed and used internally at atopile. Discussion planning to open this up publicly
These are built, known to work and come with a functioning layout too.

Also, Google is your friend. Packages are often publicly available on github or other repositories.

## Managing dependencies

You can manage dependencies using three commands: `ato add`, `ato sync` and `ato remove`.

Installed dependencies are kept in sync by all of these commands, so you don't need to think too much about managing environments.

If you pull a new project, just run `ato sync` to install the dependencies.

If you want to add a new dependency, run `ato add {package}`. It'll be added to the `ato.yaml` config file and synced for you.

If you want to remove a dependency, run `ato remove {package}`. It'll be removed from the `ato.yaml` config file and synced for you.

<Tip>
    atopile manages dependencies in a similar way to [uv](https://docs.astral.sh/uv/). If you know how that works, think about it in the same way!
</Tip>

## Development dependencies

You can install dependencies from git:

`ato add git://{git-url}`

or from a local directory:

`ato add file://./path/to/package`

Importantly, you cannot publish a package that depends on unpublished packages.
